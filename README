An introduction to x86 64-bit assembly. I've decided to do this because
most entry-level assembly code is 32-bit.
Each code has a number in its name. In the file starting with 1 I assume
you've read 0 first, in 2 I assume you've read 1, and so on.

1) About assembly
  Assembly is a family of programming languages. They are the lowest-level
programming languages, meaning they speak almost directly to the computer,
and lack abstractions common in high-level languages - such as classes,
loops like 'while' and 'for', and even the infamous 'if'.
  Unlike C, assembly code isn't meant to run on every computer - i.e.
it's not portable. One could argue most C programs use an OS's API,
so it isn't really portable, which is true. Also, some C programs rely
on a certain compiler's features, which, again, compromises portability.
But no C program is made only for a specific type of processor, and
that's where C differs from assembly. Assembly code made for one
processor will not necessarily run on another one.
  The actual assembly code depends on:
  a) the processor's architecture (x86-64, i386, ARM, etc);
  b) the assembler (nasm, as (the GNU assembler), etc);
  c) Intel or AT&T syntax, if the assmbler supports both;
  d) the operating system (becuase of stuff defined in an OS's ABI:
     Application Binary Interface).
  All of which makes assembly not very straightforward. What is more,
there are several technical details that make learning assembly difficult.
  With all this in mind...

2) Why learn assembly?
<https://software.intel.com/en-us/articles/introduction-to-x64-assembly/>
"Assembly is often used for performance-critical parts of a program,
although it is difficult to outperform a good C++ compiler for most
programmers. Assembly knowledge is useful for debugging code - sometimes
a compiler makes incorrect assembly code and stepping through the code in
a debugger helps locate the cause. Code optimizers sometimes make
mistakes. Another use for assembly is interfacing with or fixing code for
which you have no source code. Disassembly lets you change/fix existing
executables. Assembly is necessary if you want to know how your language
of choice works under the hood - why some things are slow and others are
fast. Finally, assembly code knowledge is indispensable when
diagnosing malware."

3) System requirements
  The code here will only work in a Linux-based OS, and a processor
with the x86-64 architecture. If you don't know yours, run
	$ uname -m
  To assemble the code, you'll need either 'nasm' (Netwide Assembler),
version 2.12 or greater, or 'as' (GNU Assembler); to link it,
any linker will do. (ld and gold come with binutils, so chances are
you have them already).
For assembly code that uses C library functions, you'll need an
implementation of the C library; glibc will do (once again, you probably
have it). gcc isn't strictly needed, but it makes it easier to link
such code.

4) How to assemble and link

Assembling (nasm):
	$ nasm -g -f elf64 foo.asm
The -g switch is to produce debugging information, for e.g gdb,
and it's optional. The -f switch specifies the format
(in this case, the 64-bit Executable and Linking Format (ELF)).

Assembling (as):
	$ as -g -o foo.o foo.s
The format is assumed to match your PC's architecture.

If everything goes well, you should get a foo.o file.
Linking:
	$ ld -o foo foo.o		# default
	$ gcc -o [-no-pie] foo foo.o -v	# if your file contains C function calls

The -o switch (in both lines) specifies the executable's name;
if omitted, it will be named a.out.
The -v switch (in the 2nd line) is optional, and increases verbosity,
in case you want to see what gcc is doing under the hood.
If, upon trying to execute the executable, you get
	bash: ./foo: No such file or directory
It means something went wrong when linking, but you've got an useless
file nonetheless. Sweet.
You may need the -no-pie option when linking with gcc if your code is using
absolute addresses.

5) References
  There are several loose references in the code, such as 'ABI',
'instruction set', etc. Here are the documents I'm citing:

ABI				System V Application Binary Interface,
				AMD64 Architecture Processor Supplement,
				Draft Version 0.99.8

Basic architecture		Intel(R) 64 and IA-32 Architectures
				Software Developer’s Manual
				Volume 1: Basic Architecture

Instruction set			Intel(R) 64 and IA-32 Architectures
				Software Developer’s Manual
				Volume 2 (2A, 2B & 2C): Instruction Set
				Reference, A-Z

NASM manual			NASM - The Netwide Assembler,
				version 2.12.01

AS manual			https://sourceware.org/binutils/docs/as/

System programming guide	Intel(R) 64 and IA-32 Architectures
				Software Developer’s Manual
				Volume 3 (3A, 3B, 3C & 3D): System
				Programming Guide

It's also noteworthy that the number corresponding to each system call
can be found in '/usr/include/asm/unistd_64.h'.
